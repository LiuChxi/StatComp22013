---
title: "Function guidelines"
author: '22013'
date: '2022-11-30'
output: html_document
vignette: >
  %\VignetteIndexEntry{Introduction to StatComp22013}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Function:bmykmeans

This function calculate the center of K-mean cluster using R and return the cluster of each point.The following is the basic idea of the algorithm.

1. Initialize the data, and select k objects as the center point.
2. Traverse the entire dataset, calculate the distance between each point and each center point, and assign it to the group closest to the center.
3. Recalculate the average value of each group as the new cluster center.
4. In the above 2-3 steps, the process is repeated until the function converges and no new grouping occurs.

```{r}
bmykmeans<-function(dataset,k){
  rowdata<-nrow(dataset)
  continue.change=TRUE
  
  #Randomly select k points as initial clustering points
  formerPoint<-dataset[sample.int(rowdata,size = k),]
  iterPoint<-matrix(0,nrow = k,ncol = ncol(dataset))
  
  #Record the distance from each point to each class
  error.matrix<-matrix(0,nrow=rowdata,ncol=k)
  while(continue.change){
    #Record which class each point belongs to
    cluster.matrix<-matrix(0,nrow=rowdata,ncol=k)
    for(i in 1:rowdata){
      #Calculate the distance from each point to the initial center points
      for(j in 1:k){
        error.matrix[i,j]<-sqrt(sum((dataset[i,]-formerPoint[j,])^2))
      }
    }
    #Calculate the class of each point
    for(i in 1:rowdata){
      cluster.matrix[i,which.min(error.matrix[i,])]<-1
    }
    
    #Update new centroid position
    for(i in 1:k){
      iterPoint[i,]<-apply(dataset[which(cluster.matrix[,i] == 1),],2,"mean")
    }
    all.true<-c()
    
    #Judge whether the center point has remained unchanged
    for(i in 1:k){
      if(all(formerPoint[i,] == iterPoint[i,]) == T){
        all.true[i]<-TRUE
      }
    }
    formerPoint = iterPoint
    continue.change=ifelse(all(all.true) == T,F,T)
  }
  colnames(iterPoint)<-colnames(dataset)
  result=list()
  result[["centers"]]<-iterPoint
  result[["distance"]]<-error.matrix
  result[["cluster"]]<-rep(1,rowdata)
  for(i in 1:rowdata){
    result[["cluster"]][i]<-which(cluster.matrix[i,] == 1)
  }
  #Return results, including the coordinates of the center point, the location of each point from each center point, and the cluster name of each data point
  return(result)
}
```

K-means algorithm also has some shortcomings, which is sensitive to outliers and will be affected by some extreme values.

## Function:bmymixnorsam

This function can generate a mixed distribution of two normal distributions in mode 1 and a two-dimensional normal distribution in mode 2. Mode 1 adopts independent sampling algorithm with normal distribution as the  proposed distribution, and mode 2 adopts gibbs sampling algorithm.

1. mode 1:mixed distribution
In this model, the normal distribution is taken as the proposed distribution, and the independent sampling algorithm is used for random number sampling.

2. mode 2:two-dimensional normal distribution
In this mode, gibbs sampling algorithm is used for random number sampling.

```{r}
bmymixnorsam<-function(mode,burn,p,mu1,sigma1,mu2,sigma2,mu0,sigma0,m,rho){
  if(mode == 1){
    f<-function(s){
        p*(2*pi*(sigma1^2))^(-1/2)*exp(-((s-mu1)^2)/(2*(sigma1^2)))+
        (1-p)*(2*pi*(sigma2^2))^(-1/2)*exp(-((s-mu2)^2)/(2*(sigma2^2)))
    }
    x<-numeric(m)
    # Write the parameters of the proposed distribution (modifiable)
    x[1]<-rnorm(1,mu0,sigma0)
    u<-runif(m)
    for(i in 2:m){
      xt<-x[i-1] 
      y<-rnorm(1,mu0,sigma0) 
      #mh
      num<-f(y)*dnorm(xt,mu0,sigma0) 
      den<-f(xt)*dnorm(y,mu0,sigma0) 
      #Judge whether to accept the random number generated by the proposed distribution
      if(u[i]<=num/den) 
        x[i]<-y 
      else{
        x[i]<-xt 
      }
    }
    picchain<-plot(x[burn+1:m],type = "l",ylab="x")
    
    result1=list()
    result1[["chain"]]<-x[burn+1:m]
    result1[["convergence"]]<-picchain
    
    return (result1)
  }
  #Generate two-dimensional normal distribution
  if(mode == 2){
    X<-matrix(0,m,2)
    s1<-sqrt(1-rho^2)*sigma1
    s2<-sqrt(1-rho^2)*sigma2
    
    X[1,]<-c(mu1,mu2)
    #gibbs
    for(i in 2:m){
      x2<-X[i-1,2]
      m1<-mu1+rho*(x2-mu2)*sigma1/sigma2
      X[i,1]<-rnorm(1,m1,s1)
      
      x1<-X[i-1,1]
      m2<-mu2+rho*(x1-mu1)*sigma2/sigma1
      X[i,2]<-rnorm(1,m2,s2)
    }
    xx<-X[(burn+1):m,]
    picchain<-plot(xx,main="",ylim=range(xx[,2]))
    
    result2=list()
    result2[["chain"]]<-xx
    result2[["Plot"]]<-picchain
    
    return (result2)
  }
  
}
```

