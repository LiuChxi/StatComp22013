## -----------------------------------------------------------------------------
bmykmeans<-function(dataset,k){
  rowdata<-nrow(dataset)
  continue.change=TRUE
  
  #Randomly select k points as initial clustering points
  formerPoint<-dataset[sample.int(rowdata,size = k),]
  iterPoint<-matrix(0,nrow = k,ncol = ncol(dataset))
  
  #Record the distance from each point to each class
  error.matrix<-matrix(0,nrow=rowdata,ncol=k)
  while(continue.change){
    #Record which class each point belongs to
    cluster.matrix<-matrix(0,nrow=rowdata,ncol=k)
    for(i in 1:rowdata){
      #Calculate the distance from each point to the initial center points
      for(j in 1:k){
        error.matrix[i,j]<-sqrt(sum((dataset[i,]-formerPoint[j,])^2))
      }
    }
    #Calculate the class of each point
    for(i in 1:rowdata){
      cluster.matrix[i,which.min(error.matrix[i,])]<-1
    }
    
    #Update new centroid position
    for(i in 1:k){
      iterPoint[i,]<-apply(dataset[which(cluster.matrix[,i] == 1),],2,"mean")
    }
    all.true<-c()
    
    #Judge whether the center point has remained unchanged
    for(i in 1:k){
      if(all(formerPoint[i,] == iterPoint[i,]) == T){
        all.true[i]<-TRUE
      }
    }
    formerPoint = iterPoint
    continue.change=ifelse(all(all.true) == T,F,T)
  }
  colnames(iterPoint)<-colnames(dataset)
  result=list()
  result[["centers"]]<-iterPoint
  result[["distance"]]<-error.matrix
  result[["cluster"]]<-rep(1,rowdata)
  for(i in 1:rowdata){
    result[["cluster"]][i]<-which(cluster.matrix[i,] == 1)
  }
  #Return results, including the coordinates of the center point, the location of each point from each center point, and the cluster name of each data point
  return(result)
}

## -----------------------------------------------------------------------------
bmymixnorsam<-function(mode,burn,p,mu1,sigma1,mu2,sigma2,mu0,sigma0,m,rho){
  if(mode == 1){
    f<-function(s){
        p*(2*pi*(sigma1^2))^(-1/2)*exp(-((s-mu1)^2)/(2*(sigma1^2)))+
        (1-p)*(2*pi*(sigma2^2))^(-1/2)*exp(-((s-mu2)^2)/(2*(sigma2^2)))
    }
    x<-numeric(m)
    # Write the parameters of the proposed distribution (modifiable)
    x[1]<-rnorm(1,mu0,sigma0)
    u<-runif(m)
    for(i in 2:m){
      xt<-x[i-1] 
      y<-rnorm(1,mu0,sigma0) 
      #mh
      num<-f(y)*dnorm(xt,mu0,sigma0) 
      den<-f(xt)*dnorm(y,mu0,sigma0) 
      #Judge whether to accept the random number generated by the proposed distribution
      if(u[i]<=num/den) 
        x[i]<-y 
      else{
        x[i]<-xt 
      }
    }
    picchain<-plot(x[burn+1:m],type = "l",ylab="x")
    
    result1=list()
    result1[["chain"]]<-x[burn+1:m]
    result1[["convergence"]]<-picchain
    
    return (result1)
  }
  #Generate two-dimensional normal distribution
  if(mode == 2){
    X<-matrix(0,m,2)
    s1<-sqrt(1-rho^2)*sigma1
    s2<-sqrt(1-rho^2)*sigma2
    
    X[1,]<-c(mu1,mu2)
    #gibbs
    for(i in 2:m){
      x2<-X[i-1,2]
      m1<-mu1+rho*(x2-mu2)*sigma1/sigma2
      X[i,1]<-rnorm(1,m1,s1)
      
      x1<-X[i-1,1]
      m2<-mu2+rho*(x1-mu1)*sigma2/sigma1
      X[i,2]<-rnorm(1,m2,s2)
    }
    xx<-X[(burn+1):m,]
    picchain<-plot(xx,main="",ylim=range(xx[,2]))
    
    result2=list()
    result2[["chain"]]<-xx
    result2[["Plot"]]<-picchain
    
    return (result2)
  }
  
}

